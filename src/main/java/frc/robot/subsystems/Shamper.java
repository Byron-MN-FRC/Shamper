// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.revrobotics.CANSparkBase.IdleMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANSparkFlex;
import com.revrobotics.CANSparkLowLevel.MotorType;
import com.revrobotics.CANSparkMax;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj2.command.SubsystemBase;

/**
 *
 */
public class Shamper extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax bottomLeft;
    private CANSparkMax bottomRight;
    private CANSparkFlex topLeft;
    private CANSparkFlex topRight;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax bottomRight2;

    public double defaultRPM = 240;
    private double maxRPMVortex = 6780;
    private double maxRPMNeo550 = 11000;
    // private double gearRatioDoubleNeo550 = maxRPMNeo550 / 3;
    // private double gearRatioSingleNeo550 = maxRPMNeo550 / 10;
    private double bottomRightGearRatio = maxRPMNeo550 / 3;
    private double bottomLeftGearRatio = maxRPMNeo550 / 10;

    private double topRightTargetRPM;
    private double topRightMeasuredRPM;
    private double topLeftTargetRPM;
    private double topLeftMeasuredRPM;
    private double bottomLeftTargetRPM;
    private double bottomLeftMeasuredRPM;
    private double bottomRightTargetRPM;
    private double bottomRightMeasuredRPM;

    private double bottomLeftCorrectionFactor;
    private double topRightCorrectionFactor;
    private double bottomRightCorrectionFactor;
    private double topLeftCorrectionFactor;

    private boolean bottomLeftIsInverted = true;
    private boolean bottomRightIsInverted = false;
    private boolean bottomRight2IsInverted = !bottomRightIsInverted; // motor is mount oposite of bottomRight so needs to be the opposite
    private boolean topLeftIsInverted = true;
    private boolean topRightIsInverted = false;

    private int bottomLeftCanID = 21;
    private int bottomRightCanID = 26;
    private int bottomRight2CanID = 20;
    private int topLeftCanID = 27;
    private int topRightCanID = 28;

    /**
    *
    */
    public Shamper() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        bottomLeft = new CANSparkMax(bottomLeftCanID, MotorType.kBrushless);
        bottomLeft.setInverted(bottomLeftIsInverted);
        bottomLeft.setIdleMode(IdleMode.kBrake);
        bottomLeft.burnFlash();

        bottomRight = new CANSparkMax(bottomRightCanID, MotorType.kBrushless);
        bottomRight.setInverted(bottomRightIsInverted);
        bottomRight.setIdleMode(IdleMode.kBrake);
        bottomRight.burnFlash();

        topLeft = new CANSparkFlex(topLeftCanID, MotorType.kBrushless);
        topLeft.setInverted(topLeftIsInverted);
        topLeft.setIdleMode(IdleMode.kBrake);
        topLeft.burnFlash();

        topRight = new CANSparkFlex(topRightCanID, MotorType.kBrushless);
        topRight.setInverted(topRightIsInverted);
        topRight.setIdleMode(IdleMode.kBrake);
        topRight.burnFlash();

        bottomRight2 = new CANSparkMax(bottomRight2CanID, MotorType.kBrushless);
        bottomRight2.setInverted(bottomRight2IsInverted);
        bottomRight2.setIdleMode(IdleMode.kBrake);
        bottomRight2.burnFlash();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void runAll() {
        bottomLeftTargetRPM = SmartDashboard.getNumber("Bottom Left RPM", defaultRPM);
        bottomLeftMeasuredRPM = SmartDashboard.getNumber("Bottom Left Measured RPM", defaultRPM);
        bottomRightTargetRPM = SmartDashboard.getNumber("Bottom Right RPM", defaultRPM);
        bottomRightMeasuredRPM = SmartDashboard.getNumber("Bottom Right Measured RPM", defaultRPM);
        topLeftTargetRPM = SmartDashboard.getNumber("Top Left RPM", defaultRPM);
        topLeftMeasuredRPM = SmartDashboard.getNumber("Top Left Measured RPM", defaultRPM);
        topRightTargetRPM = SmartDashboard.getNumber("Top Right RPM", defaultRPM);
        topRightMeasuredRPM = SmartDashboard.getNumber("Top Right Measured RPM", defaultRPM);

        // Determine the corrections to
        bottomLeftCorrectionFactor = bottomLeftTargetRPM / bottomLeftMeasuredRPM;
        bottomRightCorrectionFactor = bottomRightTargetRPM / bottomRightMeasuredRPM;
        topRightCorrectionFactor = topRightTargetRPM / topRightMeasuredRPM;
        topLeftCorrectionFactor = topLeftTargetRPM / topLeftMeasuredRPM;

        bottomLeft.set(bottomLeftTargetRPM / bottomLeftGearRatio * bottomLeftCorrectionFactor);
        bottomRight2.set(bottomLeftTargetRPM / bottomLeftGearRatio * bottomLeftCorrectionFactor);
        bottomRight.set(bottomRightTargetRPM / bottomRightGearRatio * bottomRightCorrectionFactor);
        topLeft.set(topLeftTargetRPM / maxRPMVortex * topLeftCorrectionFactor);
        topRight.set(topRightTargetRPM / maxRPMVortex * topRightCorrectionFactor);
    }

    public void shoot() {
        topRightTargetRPM = SmartDashboard.getNumber("TL-RPM", defaultRPM);
        topRightMeasuredRPM = SmartDashboard.getNumber("Vortex Measured Speed", defaultRPM);
        topRightCorrectionFactor = topRightTargetRPM / topRightMeasuredRPM;
        bottomLeft.set(1);
        bottomRight2.set(1);
        bottomRight.set(1);
        topLeft.set((SmartDashboard.getNumber("TL-RPM", defaultRPM) / maxRPMVortex) * topRightCorrectionFactor);
        topRight.set((SmartDashboard.getNumber("TR-RPM", defaultRPM) / maxRPMVortex) * topRightCorrectionFactor);
    }

    public void stopall() {
        bottomLeft.set(0);
        bottomRight2.set(0);
        bottomRight.set(0);
        topLeft.set(0);
        topRight.set(0);
    }

}
